/*
 * generated by Xtext
 */
package org.xtext.de.htwg.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.xtext.de.htwg.plugin.Method
import org.xtext.de.htwg.plugin.Enumeration
import org.xtext.de.htwg.plugin.MyProperty
import org.xtext.de.htwg.plugin.Interface
import javax.inject.Inject
import org.xtext.de.htwg.plugin.Import
import org.xtext.de.htwg.plugin.Plugin

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class PluginGenerator implements IGenerator {
	
	@Inject extension IQualifiedNameProvider
	
	val implSubpackageName = "impl"
	val mockSubpackageName = "mock"
	
	val pluginTuiName = "PluginTUI"
	val pluginImplModuleName = "PluginImplModule"
	val pluginMockModuleName = "PluginMockModule"
	val pluginMainName = "PluginMain"
	var rootPackage = org::eclipse::xtext::naming::QualifiedName::EMPTY;
	var pluginName = ""
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		// Find root package name
		for (e: resource.allContents.toIterable.filter(typeof(Plugin))) {
			rootPackage = e.fullyQualifiedName;
			pluginName = e.name.toLowerCase().toFirstUpper();
		}
		
		// Generate interfaces
		for (e: resource.allContents.toIterable.filter(typeof(Interface))) {
			fsa.generateFile(
				e.fullyQualifiedName.toString("/") + ".java",
				e.compileInterface)
		}
		
		// Generate impl classes
		for (e: resource.allContents.toIterable.filter(typeof(Interface))) {
			fsa.generateFile(
				e.fullyQualifiedName.skipLast(1).toString("/") + "/" + implSubpackageName + "/" + getClassName(e.fullyQualifiedName.lastSegment) + ".java",
				e.compile(implSubpackageName))
		}
		
		// Generate mock classes
		for (e: resource.allContents.toIterable.filter(typeof(Interface))) {
			fsa.generateFile(
				e.fullyQualifiedName.skipLast(1).toString("/") + "/" + mockSubpackageName + "/" + getClassName(e.fullyQualifiedName.lastSegment) + ".java",
				e.compile(mockSubpackageName))
		}
		
		// Generate Enumerations
		for (e: resource.allContents.toIterable.filter(typeof(Enumeration))) {
			fsa.generateFile(
				e.fullyQualifiedName.toString("/") + ".java",
				e.compile())
		}
		
		// TUI
		fsa.generateFile(
			rootPackage.toString("/") + "/views/tui/" + pluginTuiName + ".java",
			compileTUI(rootPackage.toString, pluginTuiName)
		)
		
		// Guice Impl Module
		fsa.generateFile(
			rootPackage.toString("/") + "/module/" + pluginImplModuleName + ".java",
			compileModule(rootPackage.toString, pluginImplModuleName, implSubpackageName)
		)
		
		// Guice Mock Module
		fsa.generateFile(
			rootPackage.toString("/") + "/module/" + pluginMockModuleName + ".java",
			compileModule(rootPackage.toString, pluginMockModuleName, mockSubpackageName)
		)
		
		// Main
		fsa.generateFile(
			rootPackage.toString("/") + "/" + pluginMainName + ".java",
			compileMain(rootPackage.toString, pluginMainName, pluginTuiName, pluginImplModuleName)
		)
	}
	
	def compileInterface(Interface iface)'''
		«IF iface.eContainer != null»
			package «iface.eContainer.fullyQualifiedName»;
			
			«FOR i:iface.eContainer.eContents.filter(typeof(Import))»
				import «rootPackage».«i.importedNamespace»;
			«ENDFOR»
		«ENDIF»
		
		/**
		 * Generated model interface «iface.name».
		 * @author TODO
		 * @version TODO
		 */
		public interface «iface.name» {
			«FOR p:iface.properties»
				«p.compilePropertyGetterSetterInterface»
			«ENDFOR»
			
			«FOR m:iface.methods»
				«m.compileMethodInterface»
			«ENDFOR»
		}
	'''
	
	def compile(Interface iface, String packageExtension)'''
		«IF iface.eContainer != null»
			package «iface.eContainer.fullyQualifiedName».«packageExtension»;
			
			import «iface.eContainer.fullyQualifiedName».*;
			
			«FOR i:iface.eContainer.eContents.filter(typeof(Import))»
				import «rootPackage».«i.importedNamespace»;
			«ENDFOR»
		«ENDIF»

		/**
		 * Generated model class «iface.name».
		 * @author TODO
		 * @version TODO
		 */
		public class « getClassName(iface.name)» implements «iface.name» {
			«FOR p:iface.properties»
				«IF p != null »
					«p.compilePropertyMember»
				«ENDIF»
			«ENDFOR»
			
			«FOR p:iface.properties»
				«p.compilePropertyGetterSetter»
			«ENDFOR»
			
			«FOR m:iface.methods»
				«m.compileMethod»
			«ENDFOR»
		}
	'''

	def compile(Enumeration enumeration)'''
		«IF enumeration.eContainer != null»
			package «enumeration.eContainer.fullyQualifiedName»;
			
			«FOR i:enumeration.eContainer.eContents.filter(typeof(Import))»
				import «rootPackage».«i.importedNamespace»;
			«ENDFOR»
		«ENDIF»

		/**
		 * Generated enumeration «enumeration.name».
		 * @author TODO
		 * @version TODO
		 */
		public enum «enumeration.name» {
			«FOR e:enumeration.enumValues SEPARATOR ", "»
				«e.toFirstUpper»
			«ENDFOR»
		}
	'''
	
	def compilePropertyMember(MyProperty p) '''

		/**
		 * The «p.name» member.
		 */
		private «p.type.fullyQualifiedName.lastSegment» «p.name»;
	'''
	
	def compilePropertyGetterSetter(MyProperty p) '''

		@Override
		public «p.type.fullyQualifiedName.lastSegment» get«p.name.toFirstUpper»() {
			return «p.name»;
		}

		@Override
		public void set«p.name.toFirstUpper»(«p.type.fullyQualifiedName.lastSegment» «p.name») {
			this.«p.name» = «p.name»;
		}
	'''
	
	def compilePropertyGetterSetterInterface(MyProperty p) '''

		/**
		 * Gets the «p.name».
		 * @return The «p.name».
		 */
		public «p.type.fullyQualifiedName.lastSegment» get«p.name.toFirstUpper»();

		/**
		 * Sets the «p.name».
		 * @param «p.name» The «p.name» value.
		 */
		public void set«p.name.toFirstUpper»(«p.type.fullyQualifiedName.lastSegment» «p.name»);
	'''
	
	def compileMethod(Method p) '''

		@Override
		public «p.type.fullyQualifiedName.lastSegment» «p.name.toFirstLower»(«FOR prm:p.params SEPARATOR ", "»«prm.type.fullyQualifiedName.lastSegment» «prm.name»«ENDFOR») {
			//TODO: implement method
			throw new UnsupportedOperationException("Method is not implemented.");
		}
	'''
	
	def compileMethodInterface(Method p) '''

		/**
		 * TODO: Method description...
		 * «IF p.params != null»@param TODO: describle all parameters...«ENDIF»
		 * «IF !p.type.fullyQualifiedName.toString.equals("void")»@return TODO: Return value description...«ENDIF»
		 */
		public «p.type.fullyQualifiedName.lastSegment» «p.name.toFirstLower»(«FOR prm:p.params SEPARATOR ", "»«prm.type.fullyQualifiedName.lastSegment» «prm.name»«ENDFOR»);
	'''
	
	def compileTUI(String basePackage, String className)'''
		package «basePackage».views.tui;
		
		import com.google.inject.Inject;
		
		/**
		 * The text user interface of the plugin.
		 */
		public class «className» {
		
			public «className»() {
			}
		
			/**
			 * updates the UI.
			 */
			public void update() {
				printTUI();
			}
		
			/**
			 * Processes the input line.
			 * @param line The input.
			 * @return TRUE, if the input was accepted.
			 */
			public boolean processInputLine(String line) {
				return true;
			}
		
			/**
			 * Prints the TUI.
			 */
			public void printTUI() {
				
			}
		}
	'''
	
	def compileModule(String basePackage, String className, String subPackage)'''
		package «basePackage».module;
		
		import com.google.inject.AbstractModule;
		
		import «basePackage».database.I«pluginName»Database;
		import «basePackage».controller.I«pluginName»Controller;
		import «basePackage».model.I«pluginName»;
		
		/**
		 * Final Google Guice module description of the plugin module.
		 */
		public class «className» extends AbstractModul {
		
			@Override
			protected void configure() {
		    	bind(I«pluginName»Controller.class).to(«basePackage».controller.«subPackage».«pluginName»Controller.class);   
				bind(I«pluginName»Database.class).to(«basePackage».database.«subPackage».«pluginName»Database.class);
			    bind(I«pluginName».class).to(«basePackage».model.«subPackage».«pluginName».class);	
			}
		}
	'''
	
	def compileMain(String basePackage, String className, String tuiName, String implModuleName)'''
		package «basePackage»;

		import java.io.BufferedReader;
		import java.io.File;
		import java.io.IOException;
		import java.io.InputStreamReader;
		
		import com.google.inject.Injector;
		import com.google.inject.Guice;
		
		import «basePackage».module.«implModuleName»;
		import «basePackage».views.tui.«tuiName»;
		
		/**
		 * The plugins startup class.
		 */ 
		class «className» {
			
			private static Injector INJECTOR = Guice.createInjector(new «implModuleName»());
			
			/**
			 * The programs main.
			 * 
			 * @param argsThe default program arguments.
			 * @throws IOException 
			 */
			public static void main(String[] args) throws IOException {			
				«tuiName» tui = new «tuiName»();

				InputStreamReader isr = new InputStreamReader(System.in, "UTF-8");
				BufferedReader br = new BufferedReader(isr);
				do {
					tui.printTUI();
					System.out.printf("%n> ");
				}while(tui.processInputLine(br.readLine()));
				
				System.out.println("exit.");
			}
		}
	'''
	
	def getClassName(String interfaceName) {
		interfaceName.substring(1).toFirstUpper;
	}
}
